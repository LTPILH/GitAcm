反素数


Code:

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <string>
#include <ctype.h>
#include <vector>
#include <algorithm>
#include <set>
#include <utility>
#include <stack>
#include <queue>
#include <sstream>
#include <cmath>
#include <time.h>
#include <map>

using namespace std;
#define rep(i,n) for(int i=0; i<n; i++)
#define repe(i,n) for(int i=1; i<=n; i++)
#define mst(A,k) memset(A,k,sizeof(A))
#define lo o<<1
#define ro (o<<1)+1
typedef unsigned long long ull;
typedef long long ll;
const double eps = 1e-8;
const ll MOD = 1e9+7;
const ll INF = 1e15;
const int N = 50005;
const int M = 600000;
const double pi = acos(-1);

int pri[1000],_pri,use[5000];
ull ans;
ull MAXV;
ll n;
void Prime()
{
	mst(use,0);
	_pri = 0;
	for(int i=2; i<5000; i++) if(!use[i])
	{
		pri[_pri++] = i;
		for(int j=i; j<5000; j+=i) use[j] = 1;
	}
}
ll Judge(int n,int m)
{
	ll res = 1;
	for(int i=1; i<=m; i++)
	{
		if(res * 1.0 * (n + i) / i > MAXV * 1.0) return -1;
		res = res * (n + i) / i; // 总觉得中间过程还是有可能溢出。。。。
		/*  这里2B了，可能两个都不能整除，但相乘后可以
		if((n + i) % i == 0)
		{
			int tmp = (n + i) / i;
			res = res * tmp;
		}
		else
		{
			res = res / i;
			res = res * (n + i);
		}*/
	}
	return res;
}
void dfs(ull res,int k,int sum,int lim,ll n)
{
	if(res >= ans) return;
	if(1 == n)
	{
		ans = res;
		return;
	}
	ll mul = 1,tmp = 1,ss;
	for(int i=1; i<=lim; i++)
	{
		if(mul * 1.0 * pri[k] > MAXV * 1.0) break;
		mul *= pri[k];
		if(res * 1.0 * mul > MAXV * 1.0) break;
		if((tmp = Judge(sum,i)) == -1) break;
		if(n % tmp != 0) continue;
		dfs(res * mul,k+1,sum+i,i,n / tmp);
	}
}
int main()
{
	//freopen("out.txt","w",stdout);

	Prime();
	MAXV = 1;
	MAXV = (MAXV << 63) - 1;
	while(cin>>n)
	{
		ans = MAXV;
		if(n == 1) ans = 2;
		else dfs(1,0,0,64,n);
		cout<<n<<" "<<ans<<"\n";
	}
	return 0;
}
